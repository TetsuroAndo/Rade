このシステムは、GitHubからのイベントをDevinのセッション作成エンドポイント（`POST /v1/sessions`）にマッピングすることで実現されます。

---

## 目的システムの構築ドキュメント：GitHub BotコメントからのDevinによるPR自動修正フロー

### I. 全体フローの概要

構築するシステムの処理フローは、大きく以下の4つのステップで構成されます。

1.  **トリガー（GitHub Webhook）**: GitHub上でBot（Code Rabbitなど）がプルリクエスト（PR）にコメントを投稿するイベントを捕捉します。
2.  **データ抽出と準備**: GitHubイベントペイロードから、PRのURL、リポジトリ情報、およびBotが提供した具体的な修正指示テキストを抽出します。
3.  **Devinセッションの開始**: 抽出した情報を基に、**Devin APIのセッション作成エンドポイント** (`POST /v1/sessions`) にリクエストを送信し、Devinに修正タスクを割り当てます。
4.  **タスクの監視と完了**: セッションIDを使用してDevinの作業状況を監視し、タスク完了（修正済みPRの発行）を確認します。

### II. GitHubトリガーと抽出情報

このシステムを機能させるために、GitHub APIから取得し、Devin APIに渡す必要のある主な情報は以下の通りです。

| 情報カテゴリ | 必要な情報 | 用途（Devin APIへ） |
| :--- | :--- | :--- |
| **トリガー** | BotによるPRコメントイベント（Webhook） | フローの開始点。コメント内容を抽出する。 |
| **PR情報** | プルリクエストの完全なURL | Devinがコードベースにアクセスし、修正を適用するために必要。**セッション作成時の`prompt`に含める**。 |
| **修正指示** | Botが残した具体的なコメント内容 | Devinに実行させるタスクの詳細な指示として、**セッション作成時の`prompt`に含める**。 |
| **認証情報** | GitHubリポジトリへの読み取り/書き込み権限を持つトークン | Devinがコードをクローンし、新しい修正版のPRを発行するために必要（後述の「Secrets」としてDevinに登録）。 |

### III. Devin API連携のための事前準備（必要な情報とエンドポイント）

Devinに自動修正を実行させるためには、認証とタスク定義が必要です。

#### 1. 認証 (Authorization)

Devin APIへのすべてのリクエストには、`Authorization` ヘッダーが必要です。

*   **必須情報**: **Devin APIキー**
*   **ヘッダー形式**: `Authorization: Bearer <token>` [4, 14, 20, 72, 98, etc.]

#### 2. GitHubアクセスのための機密情報 (Secrets)

DevinがGitHubリポジトリからコードを取得し、修正をプッシュして新しいPRを作成するためには、適切なGitHubトークンが必要です。この機密情報は、Devinの**Secretsエンドポイント**を使用して安全に登録する必要があります。

| アクション | エンドポイント | 説明 |
| :--- | :--- | :--- |
| **機密情報の作成** | `POST /v1/secrets` | GitHubトークン（`value`）を組織内で暗号化して保存します。`key`は組織内で一意である必要があります。 |
| **機密情報の参照** | `GET /v1/secrets` | 登録されたシークレットのメタデータ（`secret_id`など）を取得します（値自体は返されません）。 |

#### 3. 再利用可能な指示セット (Playbooks / Knowledge)

特定の修正プロセスやコーディング標準がBotのコメントだけでは不十分な場合、あるいは修正作業を標準化したい場合は、Devinの**Playbooks**（再利用可能な指示セット）または**Knowledge**（組織の知識）を活用できます。

*   **Playbook/Knowledgeの作成**: `POST /v1/playbooks` または `POST /v1/knowledge`。
*   これらを事前に登録しておけば、セッション作成時に`playbook_id`や`knowledge_ids`を渡すことで、Devinの作業に適用できます。

### IV. Devin APIへのリクエスト（セッション作成）

GitHubイベントからの抽出情報を使用して、Devinに作業を開始させます。

#### エンドポイント

`POST https://api.devin.ai/v1/sessions`

#### リクエストボディ（`application/json`）

Devinにタスクを実行させるための主要なパラメーターは`prompt`です。

| パラメータ | 必須/任意 | 説明 |
| :--- | :--- | :--- |
| **`prompt`** | 必須 | **タスクの記述**。ここに、抽出したPR URLとBotの修正指示を組み合わせた完全な命令を記述します。例: `"Fix the issues in PR [PR URL] based on the following comment: [Bot Comment Text]. Once complete, push the fix and create a new pull request."` |
| **`idempotent`** | 任意 | `true`に設定することで、ネットワーク障害などでリクエストが重複した場合に、新しいセッションの作成を防ぎ、既存のセッションを再利用できます。 |
| **`secret_ids`** | 任意 | セッションで使用するシークレットID（GitHubトークンなど）のリスト。`None`の場合はすべてのシークレットを使用し、空のリストの場合は使用しません。 |
| **`knowledge_ids`** | 任意 | セッションで使用するナレッジIDのリスト。カスタムコーディング標準などを適用する場合に使用します。 |

#### レスポンス

セッションが正常に作成されると、一意の識別子とWebインターフェースへのURLが返されます。

```json
{
    "session_id" : "devin-xxx", // 監視に必要なID
    "url" : "https://app.devin.ai/sessions/xxx",
    "is_new_session" : true
}
```

### V. タスクの監視と完了処理

セッションが開始されたら、修正が完了し、新しいPRが発行されるまでDevinの作業を監視する必要があります。

#### 1. セッション詳細の取得（監視）

監視には、既存のセッションの詳細情報を取得するエンドポイントを使用します。

*   **エンドポイント**: `GET /v1/sessions/{session_id}`
*   **ポーリングのベストプラクティス**: Devin APIの負荷を避けるため、**10～30秒間隔**でポーリング（ステータス確認）を行うことが推奨されています。

#### 2. 完了の確認

レスポンスの**`status_enum`**フィールドを確認します。

*   **`status_enum`**が`"finished"`になるのを待ちます。
*   Devinが作業中であれば`"working"`、追加のユーザー入力が必要であれば`"blocked"`となります。

#### 3. 結果の取得

セッションの詳細レスポンスには、Devinが生成した結果が含まれます。

*   **プルリクエスト情報**: セッションがPRに関連付けられている場合、`pull_request`オブジェクトにURLが含まれることがあります。Devinが修正後の新しいPRを作成した場合、その情報がここに表示されることが期待されます（ソースにはPRレビューの例があり、PR URLが記載されています）。
*   **構造化出力 (Structured Output)**: 事前に`prompt`にJSONスキーマを定義しておくと、Devinは作業の進捗や結果をJSON形式の`structured_output`フィールドに格納します。修正されたファイル数やタスクの成否など、機械的に処理しやすい情報を取得するために、この機能の利用が有効です。

---

### まとめ

この自動修正システムは、外部のBotからの入力（コメント）をDevinの**セッション作成（`POST /v1/sessions`）**に変換し、具体的な指示と必要な認証情報（**Secrets**）を紐づけることで機能します。Devinは渡されたPR URLと指示に基づいてコード修正を実行し、最終的に新しいプルリクエストを発行（または既存のブランチを更新）します。システムの構築とは、このプロセス全体をGitHub WebhookとDevin APIコールでオーケストレーションすることに他なりません。

これはまるで、**工場のラインの「センサー（GitHubコメント）」が作動したら、「高機能な修理ロボット（Devin）」に具体的な設計図（Knowledge/Playbook）と工具（Secrets）を渡して、「作業開始の命令（POST /v1/sessions）」を出す**ようなものです。修理ロボットは自律的に作業を行い、完了したら通知（`status_enum: finished`）を送り返します。
